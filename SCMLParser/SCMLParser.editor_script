-- (c) 2025 EVEVGames, Evandro C. MIT Licensed.

local default_sprite_material = "/builtins/materials/sprite.material"
local default_sprite_sampler = "texture_sampler"

local default_z_factor = .001

local function xml(s)
    -- https://github.com/jonathanpoelen/lua-xmlparser
    -- (c) jonathanpoelen. MIT Licensed
    s = s:gsub('<!%-%-(.-)%-%->', '')
    local entities = {}
    local slashchar = string.byte('/', 1)
    local t, l = {}, {}
    local addtext = function(txt)
        txt = txt:match'^%s*(.*%S)' or ''
        if #txt ~= 0 then
            t[#t+1] = {text=txt}
        end
    end
    s:gsub('<([?!/]?)([-:_%w]+)%s*(/?>?)([^<]*)', function(type, name, closed, txt)
        if #type == 0 then
            local attrs, orderedattrs = {}, {}
            if #closed == 0 then
                local len = 0
                for all,aname,_,value,starttxt in string.gmatch(txt, "(.-([-_%w]+)%s*=%s*(.)(.-)%3%s*(/?>?))") do
                    len = len + #all
                    attrs[aname] = value
                    orderedattrs[#orderedattrs+1] = {name=aname, value=value}
                    if #starttxt ~= 0 then
                        txt = txt:sub(len+1)
                        closed = starttxt
                        break
                    end
                end
            end
            t[#t+1] = {tag=name, attrs=attrs, children={}, orderedattrs=orderedattrs}
            if closed:byte(1) ~= slashchar then
                l[#l+1] = t
                t = t[#t].children
            end
            addtext(txt)
        elseif '/' == type then
            t = l[#l]
            l[#l] = nil
            addtext(txt)
        elseif '!' == type then
            if E == name:byte(1) then
                txt:gsub('([_%w]+)%s+(.)(.-)%2', function(name, _, entity)
                    entities[#entities+1] = {name=name, value=entity}
                end, 1)
            end
        end
    end)
    return {children=t, entities=entities, tentities=tentities}
end

local function quat_from_z_deg(angle_deg)
    local rad = math.rad(angle_deg)
    local half = rad * 0.5
    local s = math.sin(half)
    local c = math.cos(half)
    return { x = 0, y = 0, z = s, w = c }
end

local function SCMLParser(opts)
    local scml = editor.get(opts.selection, "path")
    local path = string.match(scml, "^.*/")
    local name = string.match(scml, "^.*/(.-)%.[sS][cC][mM][lL]$")
    scml = string.gsub(scml, "^/", "")
    path = string.gsub(path, "^/", "")
    local file = assert(io.open(scml, "r"))
    local tab, err = xml(file:read("*a"))
    file:close()
    if err then
        error(err)
    end

    if type(tab) ~= "table" then error("Invalid XML structure.") end
    if type(tab.children) ~= "table" then error("Malformed XML: missing children nodes.") end
    if type(tab.children[1]) ~= "table" then error("Empty XML: no root element found.") end
    if tab.children[1].tag ~= "spriter_data" then error("Invalid SCML: root tag is not <spriter_data>.") end

    if type(tab.children[1].attrs) == "table" and tab.children[1].attrs.scml_version then
        print("SCML version:", tab.children[1].attrs.scml_version)
    end

    local folders = {}
    local files = {}

    local keyframes = {}
    local pivots = {}

    local entities = {}

    for _, node in pairs(tab.children[1].children) do
        if node.tag == "folder" then -- <folder>
            local folder = node.attrs.id or ""
            for _, node in pairs(node.children) do
                if node.tag == "file" then -- <file>

                    local file_id = string.match("/"..node.attrs.name, "^.*/(.-)%..-$")

                    files[file_id] = files[file_id] and (files[file_id]+1) or 0
                    node.attrs.atlas = files[file_id] 

                    folders[#folders + 1] = node.attrs
                    folders[folder..":"..(node.attrs.id or "")] = node.attrs
                end
            end -- for _, node in pairs(node.children)
        elseif node.tag == "entity" then -- <entity>

            local entity = {
                name = node.attrs.name,
                references = {},
                animations = {},
                character_maps = {}
            }
            entities[#entities + 1] = entity

            for _, node in pairs(node.children) do
                if node.tag == "character_map" then -- <character_map>
                    local maps = {}
                    entity.character_maps[#entity.character_maps + 1] = {
                        id = node.attrs.id or "0",
                        name = node.attrs.name or "",
                        maps = maps
                    }
                    for _, node in pairs(node.children) do
                        if node.tag == "map"and node.attrs.folder and node.attrs.file then -- <map>
                            maps[#maps + 1] = {
                                urls = {},
                                folder = node.attrs.folder,
                                file = node.attrs.file,
                                target_folder = node.attrs.target_folder,
                                target_file = node.attrs.target_file
                            }
                            if not entity.character_maps[node.attrs.folder..":"..node.attrs.file] then
                                entity.character_maps[node.attrs.folder..":"..node.attrs.file] = {}
                            end
                            table.insert(entity.character_maps[node.attrs.folder..":"..node.attrs.file], maps[#maps])
                        end
                    end
                elseif node.tag == "animation" then -- <animation>
                    local animation_key = node.attrs.id or "0"

                    entity.animations[node.attrs.name] = {
                        length = node.attrs.length, -- ms
                        looping = node.attrs.looping == "true" and true or false
                    }

                    entity.references[node.attrs.name] = {}

                    local animation = entity.animations[node.attrs.name]
                    local reference = entity.references[node.attrs.name]

                    if not entity.default then
                        entity.default = node.attrs.name
                    end

                    local objects = {}
                    local timelines = node.children

                    local function get_parent(parent, bone_refs, ref, name)
                        ref = ref or reference
                        name = name or ""
                        if not parent then
                            return ref, name
                        end
                        for _, node in pairs(bone_refs) do
                            if node.tag == "bone_ref" and node.attrs.id == parent then
                                if node.attrs.parent then
                                    ref, name = get_parent(node.attrs.parent, bone_refs, ref, name)
                                end
                                local parent_timeline = node.attrs.timeline
                                for _, node in pairs(timelines) do
                                    if node.tag == "timeline" and (node.attrs.id or "0") == parent_timeline then
                                        local found = false
                                        for index = 1, #ref do
                                            if ref[index].name == node.attrs.name then
                                                found = ref[index]
                                                break
                                            end
                                        end
                                        return found or {
                                            type = "bone",
                                            name = node.attrs.name,
                                            url = animation_key .. "-" .. name .. "-" .. node.attrs.name
                                        }, name .. "-" .. node.attrs.name
                                    end
                                end
                            end
                        end
                    end

                    for _, node in pairs(node.children) do
                        if node.tag == "mainline" then -- <mainline>

                            for _, node in pairs(node.children) do
                                if node.tag == "key" then -- <key>
                                    local bone_refs = node.children
                                    for _, node in pairs(node.children) do

                                        if node.tag == "bone_ref" or node.tag == "object_ref" then -- <bone_ref> or <object_ref>

                                            local type = node.tag == "bone_ref" and "bone" or "object"

                                            local timeline_key = node.attrs.timeline or ""
                                            local key = node.attrs.key or "0"

                                            local name, reparented

                                            for _, node in pairs(timelines) do
                                                if node.tag == "timeline" and (node.attrs.id or "0") == timeline_key then
                                                    name = node.attrs.name
                                                    break
                                                end
                                            end

                                            if name then
                                                local parent = node.attrs.parent

                                                if objects[name] ~= (parent or "") then
                                                    reparented = true
                                                end
                                                objects[name] = (parent or "")

                                                local parent_ref, parent_name = get_parent(parent, bone_refs)

                                                local ref = {
                                                    type = "bone",
                                                    name = name,
                                                    url = animation_key .. "-" .. parent_name .. "-" .. name
                                                }
                                                if type == "object" then
                                                    --ref.url = ref.url .. "-o"
                                                    ref.pivot = {
                                                        type = "bone",
                                                        name = name.."-p",
                                                        url = animation_key .. "-" .. parent_name .. "-" .. name .. "-p"
                                                    }
                                                    ref[#ref + 1] = ref.pivot
                                                    ref.pivot.sprite = {
                                                        type = "object",
                                                        name = name.."-s",
                                                        url = animation_key .. "-" .. parent_name .. "-" .. name .. "-s"
                                                    }
                                                    ref.pivot[#ref.pivot + 1] = ref.pivot.sprite
                                                end
                                                local found = false
                                                for index = 1, #parent_ref do
                                                    if parent_ref[index].name == name then
                                                        found = true
                                                        break
                                                    end
                                                end
                                                if not found then
                                                    parent_ref[#parent_ref + 1] = ref
                                                end
                                                local z_index = node.attrs.z_index                                        
                                                for _, node in pairs(timelines) do
                                                    if node.tag == "timeline" and (node.attrs.id or "0") == timeline_key then
                                                        if not animation[ref.url] then
                                                            animation[ref.url] = {}
                                                        end
                                                        for _, node in pairs(node.children) do
                                                            if node.tag == "key" and tonumber(node.attrs.id or 0) >= tonumber(key) then
                                                                if not keyframes[node.attrs.time or "0"] then
                                                                    keyframes[#keyframes + 1] = tonumber(node.attrs.time or 0)
                                                                    keyframes[node.attrs.time or "0"] = true
                                                                end
                                                                local key_attrs = node.attrs
                                                                node = node.children[1] or {}
                                                                if node.tag == type then
                                                                    for key, value in pairs(key_attrs) do
                                                                        if not node.attrs[key] then
                                                                            node.attrs[key] = value
                                                                        end
                                                                    end
                                                                    node.attrs.z_index = z_index
                                                                    node.attrs._last = reparented
                                                                    if not animation[ref.url][node.attrs.time or "0"] then -- tostring(key)
                                                                        if not ref.data then
                                                                            ref.data = node.attrs
                                                                            if ref.pivot then
                                                                                ref.pivot.data = {}
                                                                                ref.pivot.sprite.data = ref.data
                                                                            end
                                                                        end
                                                                        animation[ref.url][#animation[ref.url] + 1] = node.attrs
                                                                        animation[ref.url][node.attrs.time or "0"] = true
                                                                    end
                                                                end
                                                            end
                                                        end -- for _, node in pairs(node.children)
                                                    end
                                                end -- for _, node in pairs(timelines)
                                            end
                                        end
                                    end -- for _, node in pairs(node.children)
                                end
                            end -- for _, node in pairs(node.children)
                        end
                    end -- for _, node in pairs(node.children)
                end
            end -- for _, node in pairs(node.children)
        end
    end -- for _, node in pairs(tab.children[1].children)

    local atlas_max = 0
    for index = 1, #folders do
        atlas_max = math.max(atlas_max, folders[index].atlas)
    end

    for index = 0, atlas_max do
        local atlas = {}
        for index2 = 1, #folders do
            local file = folders[index2]
            if file.atlas == index then
                local image_file = io.open(path..file.name, "r")
                if not image_file then error(string.format("The image file %q is missing from the same directory as the %s.scml file. Please make sure all required image files are present and try again.", file.name, name)) end
                image_file:close()
                atlas[#atlas + 1] = string.format([==[
images {
    image: %q
    pivot_x: %.3f
    pivot_y: %.3f
}
]==],
                    path..file.name,
                    tonumber(file.pivot_x or 0.5),
                    1 - tonumber(file.pivot_y or 0.5)
                )
            end
        end
        atlas[#atlas + 1] = string.format("extrude_borders: 2\n")

        local atlas_file = assert(io.open(path..name..(index==0 and "" or ("_"..index))..".atlas", "w"))
        atlas_file:write(table.concat(atlas, "\n"))
        atlas_file:close()

    end

    table.sort(keyframes)

    for index = 1, #entities do
        local entity = entities[index]

        local collection = {
            string.format([[name: "%s"]], entity.name),
            [[scale_along_z: 0]]
        }

        local references = entity.references
        local animations = entity.animations
        local character_maps = entity.character_maps

        local function traverse_refs(anim, refs, keyframe, parent)
            parent = parent or {}
            for index = 1, #refs do
                local ref = refs[index]
                local obj = animations[anim][ref.url]
                for index2 = 1, #parent do
                    local time = tonumber(parent[index2].time)
                    if time then
                        local insert_at = #obj + 1
                        local first_time = obj[1] and tonumber(obj[1].time or 0)
                        for index3 = 1, #obj do
                            if tonumber(obj[index3].time or 0) == time then
                                insert_at = 0 -- exists
                                break
                            elseif tonumber(obj[index3].time or 0) > time and time >= first_time then
                                insert_at = index3
                                break
                            end
                        end
                        if insert_at > 0 then
                          table.insert(obj, insert_at, {time = time, _parent = true})
                        end
                    end
                end
                for index2 = 1, #obj do
                    local frame = obj[index2]
                    local time = tonumber(frame.time or 0)
                    if time >= keyframe then
                        local _a, _scale_x, _scale_y = 1, 1, 1
                        
                        for index3 = #parent, 1, -1 do
                            if tonumber(parent[index3].time or 0) <= time then
                                _a = parent[index3]._a or _a
                                _scale_x = parent[index3]._scale_x or _scale_x
                                _scale_y = parent[index3]._scale_y or _scale_y
                                break
                            end
                        end
                        if frame._parent then
                            local a, x, y, scale_x, scale_y
                            for index3 = index2 - 1, 1, -1 do
                                local this = obj[index3]
                                if this and not this._parent then
                                    a = this.a
                                    x = this.x
                                    y = this.y
                                    scale_x = this.scale_x
                                    scale_y = this.scale_y
                                    break
                                end
                            end
                            frame._a =  _a * (a or 1)
                            frame._x = _scale_x * (x or 1)
                            frame._scale_x = _scale_x * (scale_x or 1)
                            frame._y = _scale_y * (y or 1)
                            frame._scale_y =  _scale_y * (scale_y or 1)
                        else
                            frame._a = (frame.a or 1) * _a
                            frame._x = (frame.x or 0) * _scale_x
                            frame._scale_x = (frame.scale_x or 1) * _scale_x
                            frame._y = (frame.y or 0) * _scale_y
                            frame._scale_y = (frame.scale_y or 1) * _scale_y
                        end
                    end
                end
                if ref.type == "bone" and not ref.pivot then
                    traverse_refs(anim, ref, keyframe, animations[anim][ref.url])
                end
            end
        end

        local function generate_references(current, refs)
            local after = {}
            local data = {}
            for index = 1, #refs do
                local ref = refs[index]

                if ref.type == "bone" then
                    current[#current + 1] =     string.format([[  children: "%s"]], ref.url)
                    after[#after + 1] =                       [[embedded_instances {]]
                    after[#after + 1] =         string.format([[  id: "%s"]], ref.url)
                    if ref.data.angle then
                        local quat = quat_from_z_deg(tonumber(ref.data.angle))
                        after[#after + 1] =                   [[  rotation {]]
                        after[#after + 1] =     string.format([[    z: %.3f]], quat.z)
                        after[#after + 1] =     string.format([[    w: %.3f]], quat.w)
                        after[#after + 1] =                   [[  }]]
                    end
                    if ref.data.x or ref.data.y or ref.data.z_index then
                        after[#after + 1] =                   [[  position {]]
                        if ref.data.x then
                            after[#after + 1] = string.format([[    x: %.3f]], ref.data.x)
                        end
                        if ref.data.y then
                            after[#after + 1] = string.format([[    y: %.3f]], ref.data.y)
                        end
                        if ref.data.z_index then
                            after[#after + 1] = string.format([[    z: %.3f]], ref.data.z_index*default_z_factor)
                        end
                        after[#after + 1] =                   [[  }]]
                    end

                    --after[#after + 1] = string.format("  data: %q", "")
                    local results = generate_references(after, ref)
                    after[#after + 1] =                   [[}]]
                    for index = 1, #results do
                        after[#after + 1] = results[index]
                    end
                elseif ref.type == "object" then
                    local image = assert(folders[ref.data.folder..":"..ref.data.file])
                    local default_animation = string.match("/"..image.name, "^.*/(.-)%..-$")
                    pivots[ref.url] = {pivot_x = tonumber(image.pivot_x or 0.5), pivot_y = tonumber(image.pivot_y or 0.5)}
                    if character_maps[ref.data.folder..":"..ref.data.file] then
                        for _, map in pairs(character_maps[ref.data.folder..":"..ref.data.file]) do
                            local url = string.gsub(ref.url, "%-s$", "")
                            if not map.urls[url] then
                                map.urls[url] = true
                                table.insert(map.urls, url)
                            end
                            map.atlas = image.atlas
                            map.animation = default_animation
                            if map.target_file and map.target_folder then
                                local target = assert(folders[map.target_folder..":"..map.target_file])
                                map.target_atlas = target.atlas
                                map.target_animation = string.match("/"..target.name, "^.*/(.-)%..-$")
                            end
                        end
                    end

                    data[#data + 1] =                       [[  "embedded_components {\n"]]
                    data[#data + 1] =         string.format([[  "  id: \"%s\"\n"]], ref.url)
                    data[#data + 1] =                       [[  "  type: \"sprite\"\n"]]
                    data[#data + 1] =         string.format([[  "  data: \"default_animation: \\\"%s\\\"\\n"]], default_animation)
                    data[#data + 1] =         string.format([[  "material: \\\"%s\\\"\\n"]], default_sprite_material)
                    data[#data + 1] =                       [[  "textures {\\n"]]
                    data[#data + 1] =         string.format([[  "  sampler: \\\"%s\\\"\\n"]], default_sprite_sampler)
                    data[#data + 1] =         string.format([[  "  texture: \\\"/%s\\\"\\n"]], path..name..(image.atlas==0 and "" or ("_"..image.atlas))..".atlas")
                    data[#data + 1] =                       [[  "}\\n"]]
                    data[#data + 1] =                       [[  "\"\n"]]
                    if ref.data._scale_x or ref.data._scale_y then
                        data[#data + 1] =                   [[  "  scale {\n"]]
                        if ref.data._scale_x then
                            data[#data + 1] = string.format([[  "    x: %.3f\n"]], ref.data._scale_x)
                        end
                        if ref.data._scale_y then
                            data[#data + 1] = string.format([[  "    y: %.3f\n"]], ref.data._scale_y)
                        end
                        data[#data + 1] =                   [[  "  }\n"]]
                    end
                    data[#data + 1] =                       [[  "}\n"]]
                end
            end
            data[#data + 1] = [[  ""]]
            current[#current + 1] = [[  data: ]]..data[1]
            for index = 2, #data do
                current[#current + 1] = data[index]
            end
            return after
        end

        collection[#collection + 1] =                   [[embedded_instances {]]
        collection[#collection + 1] =     string.format([[  id: "%s"]], entity.name)
        for anim, _ in pairs(references) do
            collection[#collection + 1] = string.format([[  children: "%s"]], anim)
        end
        collection[#collection + 1] =                   [[  data: "components {\n"]]
        collection[#collection + 1] =     string.format([[  "  id: \"%s\"\n"]], entity.name)
        collection[#collection + 1] =     string.format([[  "  component: \"/%s\"\n"]], path..entity.name..".script")
        collection[#collection + 1] =                   [[  "}\n"]]
        collection[#collection + 1] =                   [[}]]

        for anim, refs in pairs(references) do

            -- https://github.com/EVEVGames/SCMLParser/issues/1
            for index = 1, #keyframes do
                traverse_refs(anim, refs, keyframes[index])
            end

            collection[#collection + 1] =               [[embedded_instances {]]
            collection[#collection + 1] = string.format([[  id: "%s"]], anim)
            local results = generate_references(collection, refs)
            collection[#collection + 1] =               [[}]]
            for index = 1, #results do
                collection[#collection + 1] = results[index]
            end
        end

        local script_reset = {}
        local script_animations = {}

        for animation, objects in pairs(animations) do

            script_reset[#script_reset + 1] = "-- "..animation
            script_reset[#script_reset + 1] = string.format("if not animation or animation == %q then", animation)
            script_animations[#script_animations + 1] = string.format("[%q] = {", animation)
            script_animations[#script_animations + 1] = string.format([[    run = function(self, loop)]], animation)
            --script_animations[#script_animations + 1] = string.format([[        msg.post(%q, "enable")]], animation)
            for url, frames in pairs(objects) do
                if string.match(url, "%-") then
                    local frame = frames[1]

                    if frame then
                        local type = frame.folder and "object" or "bone"
                        --script_reset[#script_reset + 1] = string.format([[    if go.exists(%q) then]], url)
                        if type == "object" and frame._scale_x then
                            script_reset[#script_reset + 1] = string.format([[    go.set(%q, "scale.x", %.3f)]], url.."-p#"..url.."-s", tonumber(frame._scale_x))
                        end
                        if type == "object" and frame._scale_y then
                            script_reset[#script_reset + 1] = string.format([[    go.set(%q, "scale.y", %.3f)]], url.."-p#"..url.."-s", tonumber(frame._scale_y))
                        end
                        if frame.angle then
                            local quat = quat_from_z_deg(tonumber(frame.angle))
                            script_reset[#script_reset + 1] = string.format([[    go.set(%q, "rotation.z", %.3f)]], url, quat.z)
                            script_reset[#script_reset + 1] = string.format([[    go.set(%q, "rotation.w", %.3f)]], url, quat.w)
                        end
                        if frame._x then
                            script_reset[#script_reset + 1] = string.format([[    go.set(%q, "position.x", %.3f)]], url, tonumber(frame._x))
                        end
                        if frame._y then
                            script_reset[#script_reset + 1] = string.format([[    go.set(%q, "position.y", %.3f)]], url, tonumber(frame._y))
                        end
                        if frame.z_index then
                            script_reset[#script_reset + 1] = string.format([[    go.set(%q, "position.z", %.3f*self.z_factor)]], url, tonumber(frame.z_index))
                        end
                        if type == "object" and frame._a then
                            script_reset[#script_reset + 1] = string.format([[    go.set(%q, "tint.w", %.3f*self.alpha_factor)]], url.."-p#"..url.."-s", tonumber(frame._a))
                        end
                        if type == "object" then
                            if frame.pivot_x then
                                script_reset[#script_reset + 1] = string.format([[    go.set(%q, "position.x", -go.get(%q, "size").x * %.3f)]], url.."-p", url.."-p#"..url.."-s", tonumber(frame.pivot_x or pivots[url.."-s"].pivot_x))
                            end
                            if frame.pivot_y then
                                script_reset[#script_reset + 1] = string.format([[    go.set(%q, "position.y", go.get(%q, "size").y * (1-%.3f))]], url.."-p", url.."-p#"..url.."-s", tonumber(frame.pivot_y or pivots[url.."-s"].pivot_y))
                            end
                        end
                        --script_reset[#script_reset + 1] = string.format([[    msg.post(%q, "disable")]], url)
                        if type == "object" then
                            --script_reset[#script_reset + 1] = string.format([[    msg.post(%q, "disable")]], url.."-p")
                            script_reset[#script_reset + 1] = string.format([[    msg.post(%q, "disable")]], url.."-p#"..url.."-s")
                        end
                        --script_reset[#script_reset + 1] = [[    end]]
                    end
                    --script_animations[#script_animations + 1] = string.format([[        if go.exists(%q) then]], url)

                    local first = frame
                    local enabled_objects = {}

                    for index = 1, #frames do
                        local frame = frames[index]
                        local type = frame.folder and "object" or "bone"
                        local previous = frames[index - 1] or first or {}
                        local next = frames[index + 1] or first or {}
                        local current_time = tonumber(frame.time or 0) / 1000
                        local total_time = tonumber(objects.length) / 1000
                        local next_time = total_time - current_time

                        if next.time then
                            next_time = (tonumber(next.time) / 1000) - current_time
                        end

                        local tab = "        "
                        local has_animation = false
                        local lines = {}

                        if not enabled_objects[url] then
                            --table.insert(lines, tab..string.format([[msg.post(%q, "enable")]], url))
                            enabled_objects[url] = true

                            if type == "object" then
                                --table.insert(lines, tab..string.format([[msg.post(%q, "enable")]], url.."-p"))
                                table.insert(lines, tab..string.format([[if not self.hidden[%q] then msg.post(%q, "enable") end]], url, url.."-p#"..url.."-s"))
                            end
                            has_animation = true
                        end

                        local function animate_if_changed(prop, val, other, path)
                            if val and other ~= val then
                                table.insert(lines, tab..string.format([[go.animate(%q, "%s", go.PLAYBACK_ONCE_FORWARD, %.3f, self.easing, %.3f)]], path or url, prop, tonumber(val), next_time))
                                has_animation = true
                            end
                        end

                        if type == "object" then
                            animate_if_changed("scale.x", next._scale_x, frame._scale_x, url.."-p#"..url.."-s")
                            animate_if_changed("scale.y", next._scale_y, frame._scale_y, url.."-p#"..url.."-s")
                        end

                        if next.angle and frame.angle ~= next.angle then
                            local quat = quat_from_z_deg(tonumber(next.angle))
                            table.insert(lines, tab..string.format([[go.animate(%q, "rotation.z", go.PLAYBACK_ONCE_FORWARD, %.3f, rotation_easing(%q, "z", %.3f), %.3f)]], url, quat.z, url, tonumber(next.angle), next_time))
                            table.insert(lines, tab..string.format([[go.animate(%q, "rotation.w", go.PLAYBACK_ONCE_FORWARD, %.3f, rotation_easing(%q, "w", %.3f), %.3f)]], url, quat.w, url, tonumber(next.angle), next_time))
                            has_animation = true
                        end

                        animate_if_changed("position.x", next._x, frame._x)
                        animate_if_changed("position.y", next._y, frame._y)

                        if next.z_index and frame.z_index ~= next.z_index then
                            table.insert(lines, tab..string.format([[go.animate(%q, "position.z", go.PLAYBACK_ONCE_FORWARD, %.3f*self.z_factor, self.easing, %.3f)]], url, tonumber(next.z_index), next_time))
                            has_animation = true
                        end
                        
                        if type == "object" and next._a and frame._a ~= next._a then
                            table.insert(lines, tab..string.format([[go.animate(%q, "tint.w", go.PLAYBACK_ONCE_FORWARD, %.3f*self.alpha_factor, self.easing, %.3f)]], url.."-p#"..url.."-s", tonumber(next._a), next_time))
                            has_animation = true
                        end

                        if type == "object" then
                            if next.pivot_x and frame.pivot_x ~= next.pivot_x then
                                table.insert(lines, tab..string.format([[go.animate(%q, "position.x", go.PLAYBACK_ONCE_FORWARD, -go.get(%q, "size").x * %.3f, self.easing, %.3f)]], url.."-p", url.."-p#"..url.."-s", tonumber(next.pivot_x), next_time))
                                has_animation = true
                            end
                            if next.pivot_y and frame.pivot_y ~= next.pivot_y then
                                table.insert(lines, tab..string.format([[go.animate(%q, "position.y", go.PLAYBACK_ONCE_FORWARD, go.get(%q, "size").y * (1-%.3f), self.easing, %.3f)]], url.."-p", url.."-p#"..url.."-s", tonumber(next.pivot_y), next_time))
                                has_animation = true
                            end
                        end

                        if current_time ~= 0 and has_animation and next_time ~= 0 then
                            script_animations[#script_animations + 1] = string.format([[        %ssave_timer(self, timer.delay(%.3f, false, function()]], next == first and "if loop then " or "", current_time)
                            for _, line in ipairs(lines) do
                                script_animations[#script_animations + 1] = "    " .. line
                            end
                            script_animations[#script_animations + 1] = string.format([[        end))%s]], next == first and " end" or "")
                        elseif current_time == 0 and next_time ~= 0 then
                            for _, line in ipairs(lines) do
                                script_animations[#script_animations + 1] = line
                            end
                        end
                    end
                    --script_animations[#script_animations + 1] = [[        end]]
                end
            end
            --script_reset[#script_reset + 1] = string.format([[    msg.post(%q, "disable")]], animation)
            script_reset[#script_reset + 1] = "end"
            script_animations[#script_animations + 1] = [[    end,]]
            script_animations[#script_animations + 1] = string.format([[    loop = %s,]], objects.looping and "true" or "false")
            script_animations[#script_animations + 1] = string.format([[    length = %.3f]], (tonumber(objects.length) / 1000)*1.1)
            script_animations[#script_animations + 1] = [[},]]
        end

        local script_character_maps = {}
        local script_reset_character_maps = {}

        for index2 = 1, #character_maps do
            local character_map = character_maps[index2]
            script_character_maps[#script_character_maps + 1] = string.format("[%q] = function(self)", character_map.name)
            for index3 = 1, #character_map.maps do
                local map = character_map.maps[index3]
                for index4 = 1, #map.urls do
                    local url = map.urls[index4]
                    script_reset_character_maps[#script_reset_character_maps + 1] = string.format([[go.set(%q, "image", hash(%q))]], url.."-p#"..url.."-s", "/"..path..name..(map.atlas==0 and "" or ("_"..map.atlas))..".a.texturesetc")
                    script_reset_character_maps[#script_reset_character_maps + 1] = string.format([[sprite.play_flipbook(%q, %q)]], url.."-p#"..url.."-s", map.animation)
                    script_reset_character_maps[#script_reset_character_maps + 1] = string.format([[self.hidden[%q] = nil]], url)
                    if map.target_animation then
                        script_character_maps[#script_character_maps + 1] = string.format([[    go.set(%q, "image", hash(%q))]], url.."-p#"..url.."-s", "/"..path..name..(map.target_atlas==0 and "" or ("_"..map.target_atlas))..".a.texturesetc")
                        script_character_maps[#script_character_maps + 1] = string.format([[    sprite.play_flipbook(%q, %q)]], url.."-p#"..url.."-s", map.target_animation)
                        script_character_maps[#script_character_maps + 1] = string.format([[    self.hidden[%q] = nil]], url)
                    else
                        script_character_maps[#script_character_maps + 1] = string.format([[    self.hidden[%q] = true]], url)
                        script_character_maps[#script_character_maps + 1] = string.format([[    msg.post(%q, "disable")]], url.."-p#"..url.."-s")
                    end
                end
            end
            script_character_maps[#script_character_maps + 1] = "end,"
        end

        local script = string.format([===[
-- Auto-generated by https://github.com/EVEVGames/SCMLParser

go.property("play", true)
go.property("animation", hash(%q))
go.property("loop", true)
go.property("alpha_factor", 1)
go.property("z_factor", %3f)

local function stop_animation(self, handler, animation)
    go.cancel_animations("#")
    for index = #self.timers, 1, -1 do
        if timer.get_info(self.timers[index]) and handler ~= self.timers[index] then
            timer.cancel(self.timers[index])
        end
        if handler ~= self.timers[index] then
            table.remove(self.timers, index)
        end
    end

    %s

end

local function reset_character_maps(self)
    %s
end

local function save_timer(self, handler)
    self.timers[#self.timers + 1] = handler
end

local function rotation_easing(url, quat, to_deg)
    local from = go.get(url, "rotation")
    local to = vmath.quat_rotation_z(math.rad(to_deg))
    local from_quat, to_quat, values = from[quat], to[quat], {}
    if from_quat == to_quat then return vmath.vector({1}) end
    for i = 1, 60 do
        values[i] = (vmath.slerp((i - 1) / 59, from, to)[quat] - from_quat) / (to_quat - from_quat)
    end
    return vmath.vector(values)
end

local animations = {
    %s
}

local character_maps = {
    %s
}

local animation_hashes, animation_names, character_maps_names = {}, {}, {}

for animation in pairs(animations) do
    animation_names[#animation_names + 1] = animation
    animation_hashes[hash(animation)] = animation
end

for character_map in pairs(character_maps) do
    character_maps_names[#character_maps_names + 1] = character_map
end

local ERROR_MESSAGE = "Animation%%s not found. Available animations are: %%s."

function init(self)
    self.easing = go.EASING_LINEAR
    self.timers = {}
    self.hidden = {}
    stop_animation(self)
    if self.play then
        local animation = animation_hashes[self.animation]
        if animation then
            animations[animation].run(self, self.loop)
            if self.loop then
                save_timer(self, timer.delay(animations[animation].length, true, function(_, handler)
                    stop_animation(self, handler, animation)
                    animations[animation].run(self, self.loop)
                end))
            end
        else
            error(string.format(ERROR_MESSAGE, "", table.concat(animation_names, ", ")))
        end
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("play_animation") then
        local animation = message.animation or animation_hashes[self.animation]
        if animation then
            local loop = message.loop or (message.loop == nil and animations[animation].loop)
            stop_animation(self)
            animations[animation].run(self, loop)
            if loop then
                save_timer(self, timer.delay(animations[animation].length, true, function(_, handler)
                    stop_animation(self, handler, animation)
                    animations[animation].run(self, loop)
                end))
            end
        else
            error(string.format(ERROR_MESSAGE, " "..(message.animation or ""), table.concat(animation_names, ", ")))
        end
    elseif message_id == hash("stop_animation") then
        stop_animation(self)
    elseif message_id == hash("list_animations") then
        msg.post(sender, hash("animations_list"), animation_names)
    elseif message_id == hash("list_character_maps") then
        msg.post(sender, hash("character_maps_list"), character_maps_names)
    elseif message_id == hash("apply_character_maps") then
        for index = 1, #message do
            local character_map = message[index]
            if character_maps[character_map] then
                character_maps[character_map](self)
            else
                error(string.format("The character map %%q does not exist.", character_map))
            end
        end
    elseif message_id == hash("reset_character_maps") then
        reset_character_maps(self)
    end
end
]===],
            entity.default,
            --entity.animations[entity.default].looping and "true" or "false",
            default_z_factor,
            table.concat(script_reset, "\n    "),
            table.concat(script_reset_character_maps, "\n    "),
            table.concat(script_animations, "\n    "),
            table.concat(script_character_maps, "\n    ")
        )

        local script_file = assert(io.open(path..entity.name..".script", "w"))
        script_file:write(script)
        script_file:close()

        local collection_file = assert(io.open(path..entity.name..".collection", "w"))
        collection_file:write(table.concat(collection, "\n"))
        collection_file:close()
    end

end

return {
    get_commands = function()
        return {
            {
                label = "Parse SCML",
                locations = {"Assets"},
                query = {
                    selection = {type = "resource", cardinality = "one"}
                },
                active = function(opts)
                    return string.match(string.lower(editor.get(opts.selection, "path")), "%.scml$")
                end,
                run = SCMLParser
            }
        }
    end
}